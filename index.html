<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Hand Landmark Debug</title>
<style>
  html,body{margin:0;padding:0;overflow:hidden;background:#000}
  #video{position:fixed;inset:0;width:100vw;height:100vh;object-fit:cover}
  #debug{position:fixed;inset:0;pointer-events:none}
  .ui{position:fixed;left:8px;top:8px;display:flex;gap:8px;z-index:10}
  .ui button{padding:6px 10px;border:0;border-radius:6px;background:#222;color:#fff}
  .hint{position:fixed;left:8px;bottom:8px;color:#fff;font:14px/1.6 system-ui;background:rgba(0,0,0,.35);padding:6px 10px;border-radius:8px}
  .err{position:fixed;left:8px;right:8px;top:48px;color:#fff;background:#b00020;padding:8px 12px;border-radius:8px;display:none;white-space:pre-wrap}
</style>
</head>
<body>
  <video id="video" playsinline muted></video>
  <canvas id="debug"></canvas>
  <div class="ui">
    <button id="frontBtn">前面</button>
    <button id="backBtn">背面</button>
  </div>
  <div id="err" class="err"></div>
  <div class="hint">手全体を30〜60cmの距離で映してください（緑点=検出）。明るい場所で。</div>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script>
(async ()=>{
  const $ = s=>document.querySelector(s);
  const err = $("#err");
  const showErr = m=>{ err.textContent=m; err.style.display='block'; console.error(m); };

  const video = $("#video");
  const dbg = $("#debug");
  const ctx = dbg.getContext('2d');
  const state = { facing: 'environment' }; // 起動時は背面

  async function openCamera() {
    try {
      const s = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ ideal: state.facing } }, audio:false });
      return s;
    } catch(e) {
      if (state.facing==='environment') {
        showErr('背面が使えないため前面にフォールバックしました。');
        state.facing = 'user';
        return await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false });
      } else {
        throw e;
      }
    }
  }

  async function startStream(){
    const stream = await openCamera();
    video.srcObject = stream;
    await video.play();
    resize();
    startHands();
  }

  function resize(){
    dbg.width = innerWidth; dbg.height = innerHeight;
  }
  addEventListener('resize', resize);

  // Buttons
  $("#frontBtn").onclick = async ()=>{ state.facing='user'; await startStream(); };
  $("#backBtn").onclick  = async ()=>{ state.facing='environment'; await startStream(); };

  // MediaPipe Hands
  const hands = new Hands({ locateFile: f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
  hands.setOptions({
    maxNumHands:1, modelComplexity:1,
    selfieMode: false, // 背面前提（前面に切替時は左右反転を気にしないデバッグ用途）
    minTrackingConfidence:0.6, minDetectionConfidence:0.6
  });

  function drawPt(x,y,r=5,color='#00ff68'){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=color; ctx.fill(); }

  function startHands(){
    const cam = new Camera(video, {
      onFrame: async ()=>{ await hands.send({ image: video }); },
      width: 640, height: 480
    });
    cam.start();
  }

  hands.onResults((res)=>{
    ctx.clearRect(0,0,dbg.width,dbg.height);
    const lm = res.multiHandLandmarks?.[0];
    if(!lm) return;
    lm.forEach(p=>{
      drawPt(p.x*dbg.width, p.y*dbg.height, 4, '#00ff68');
    });
  });

  try { await startStream(); }
  catch(e){ showErr(String(e)); }
})();
</script>
</body>
</html>
