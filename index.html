<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Hand Tracking WebAR (Back Camera + GLB follow)</title>
  <style>
    html,body{margin:0;padding:0;background:#000;overflow:hidden}
    #video{position:fixed;inset:0;width:100vw;height:100vh;object-fit:cover}
    canvas{position:fixed;inset:0}
    .hint{position:fixed;left:8px;bottom:8px;color:#fff;font:14px/1.6 system-ui;background:rgba(0,0,0,.35);padding:6px 10px;border-radius:8px}
    .err{position:fixed;left:8px;top:8px;right:8px;color:#fff;background:#b00020;padding:8px 12px;border-radius:8px;display:none;white-space:pre-wrap}
  </style>
</head>
<body>
  <video id="video" playsinline muted></video>
  <div class="hint">背面カメラで動作中。親指と人差し指を近づけるとGLBが手元に出ます。</div>
  <div id="err" class="err"></div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <!-- GLTFLoader（非モジュール版） -->
  <script src="https://unpkg.com/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  (async () => {
    const showError = (m) => { const el = document.getElementById('err'); el.textContent = m; el.style.display = 'block'; console.error(m); };

    // === 1) カメラ（背面優先・フォールバック付き） ===
    const video = document.getElementById('video');
    async function openCamera() {
      try {
        // 背面カメラを「理想」として要求
        const s1 = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' } },
          audio: false
        });
        return s1;
      } catch(e1) {
        try {
          // 一部端末は exact 指定で通ることがある
          const s2 = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: { exact: 'environment' } },
            audio: false
          });
          return s2;
        } catch(e2) {
          // 最後の手段：前面
          const s3 = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'user' },
            audio: false
          });
          showError('背面カメラが使用できなかったため、前面にフォールバックしました。端末やブラウザの設定をご確認ください。');
          return s3;
        }
      }
    }
    const stream = await openCamera();
    video.srcObject = stream;
    await video.play();

    // === 2) Three.js ===
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 100);
    camera.position.set(0,0,1.5);

    const dir = new THREE.DirectionalLight(0xffffff, 1); dir.position.set(0,1,1); scene.add(dir);
    scene.add(new THREE.AmbientLight(0xffffff, .6));

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // === 3) GLB 読み込み ===
    // 日本語名でもOK（GitHub Pagesでは英字名 model.glb を推奨）
    const MODEL_URL = encodeURI('無題.glb');
    const loader = new THREE.GLTFLoader();
    let model = new THREE.Group();
    scene.add(model);
    model.visible = false;

    loader.load(
      MODEL_URL,
      (gltf) => {
        model.add(gltf.scene);

        // 中心合わせ＆スケーリング
        const box = new THREE.Box3().setFromObject(model);
        const size = new THREE.Vector3(); box.getSize(size);
        const center = new THREE.Vector3(); box.getCenter(center);
        model.position.sub(center);

        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const targetDim = 0.15; // ≒15cm
        const s = targetDim / maxDim;
        model.scale.setScalar(s);
        model.visible = false;
        console.log('GLB loaded');
      },
      undefined,
      (err) => showError('GLBの読み込みに失敗しました：' + err)
    );

    // === 4) MediaPipe Hands（背面前提：selfieMode=false） ===
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      selfieMode: false,            // ← 重要：鏡像OFF（背面）
      minTrackingConfidence: 0.6,
      minDetectionConfidence: 0.6
    });

    const Z = 0.6; // カメラ前方の仮想距離（m相当）
    let pinchActive = false;

    hands.onResults((results) => {
      const lm = results.multiHandLandmarks?.[0];
      if (!lm || !model) { model.visible = false; return; }

      const thumbTip = lm[4];
      const indexTip = lm[8];

      // ピンチ距離で掴み判定
      const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
      pinchActive = pinchDist < 0.05;

      // 親指先と人差し指先の中点（画像座標 0..1）
      const u = (thumbTip.x + indexTip.x) * 0.5; // 0..1（左→右）
      const v = (thumbTip.y + indexTip.y) * 0.5; // 0..1（上→下）

      // === 背面用のNDC変換 ===
      const ndcX = (u * 2 - 1);
      const ndcY = ((1 - v) * 2 - 1); // 上を+にする

      // 画面位置をカメラ前方Zへ投影
      const vec = new THREE.Vector3(ndcX, ndcY, -1).unproject(camera);
      const ray = vec.sub(camera.position).normalize();
      const pos = camera.position.clone().add(ray.multiplyScalar(Z));

      model.position.copy(pos);
      model.visible = true;

      // 掴み中は少しスケールUP（演出）
      const base = model.userData._baseScale || model.scale.x;
      if (!model.userData._baseScale) model.userData._baseScale = base;
      const factor = pinchActive ? 1.15 : 1.0;
      model.scale.setScalar(base * factor);
    });

    // === 5) MediaPipe にフレームを渡す ===
    const mpCamera = new Camera(video, {
      onFrame: async () => { await hands.send({ image: video }); },
      width: 640, height: 480
    });
    mpCamera.start();

    // === 6) ループ ===
    (function loop(){
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    })();
  })();
  </script>
</body>
</html>
